[{"name": "app.py", "content": "import pandas as pd\nimport os as os\nimport numpy as np\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as mpatches\nimport os\nimport io\nimport signal\nfrom datetime import datetime\n\nfrom shiny import App, Inputs, Outputs, Session, reactive, render, ui#from shiny.express import input, render, ui\n#from shinywidgets import render_plotly\n\n#fname = './' + 'AnnArborRealEstate2023-b-noNA.csv'\n#nudata = pd.read_csv(fname)\nprotected_names = ['-']\nmax_factor_values = 50\n\ndef collisionAvoidance(name,namelist):\n    while name in namelist: \n        name = name + '_0'        \n    return(name)\n\n\n# ui.page_opts(title=\"Pivot Tabler\", fillable=True)\n\n# with ui.sidebar():\n#     ui.input_selectize(\n#         \"var\", \"Select variable\",\n#         nudata.columns\n#     )\n#     ui.input_numeric(\"bins\", \"Number of bins\", 30)\n\n#dfn = nudata.copy(deep = True)\naggopts = ['sum','mean','median', 'min', 'max', 'count' , 'std','var','count unique']\napp_ui = ui.page_navbar( \n    ui.nav_panel(\"Input\",\n        ui.input_file(\"file1\", \"Choose .csv or .dta File\", accept=[\".csv\",\".CSV\",\".dta\",\".DTA\"], multiple=False, placeholder = ''),\n        ui.input_radio_buttons('killna', 'Remove rows with missing data in one or more columns?',choices = ['No','Yes']),\n        ui.row(ui.output_data_frame(\"info\"), height = '500px'),\n        ui.row(ui.output_data_frame(\"summary\")),\n        ui.row(ui.output_data_frame(\"data\")),\n        ),\n    ui.nav_panel(\"Pivot Table\",\n                ui.row(\n                    ui.column(3,offset = 0,*[ui.input_selectize(\"aggfunV\",\"Aggregation:\",choices = aggopts,selected = 'sum', multiple = False,width = \"400px\")]),\n                    ui.column(3,offset = 0,*[ui.input_selectize(\"valuesV\",\"Values to aggregate:\",choices = ['-'],multiple = True, width = \"400px\")]),\n                    ui.column(3,offset = 0,*[ui.input_selectize(\"indexV\" ,\"Group Rows By:\",choices = ['-'],multiple = True,width = \"400px\")]),\n                    ui.column(3,offset = 0, *[ui.input_selectize(\"columnsV\",\"Group Cols By:\",choices = ['-'],multiple = True,width = \"400px\")]),\n                ),\n                ui.row(\n                    ui.column(2,offset = 0, *[ui.input_radio_buttons('nacode',\"Code Missing Values:\",choices = ['NaN','0','blank'], selected = '0', inline=True)]),\n                    ui.column(2,offset = 0, *[ui.input_numeric(\"nodig\",\"# of Digits:\", value = 3, min=0, max=10,width='100px')]),\n                    ui.column(2,offset = 0, *[ui.input_radio_buttons('mtotals',\"Show Margins:\",choices = ['Yes','No'],selected = 'No',inline = True)]), \n                    ui.column(2,offset = 0, *[ui.input_radio_buttons('dogrid', 'Grid lines?', choices = ['No','Yes'],inline = True)]),  \n                    ui.column(3,offset = 0, *[ui.input_radio_buttons('transform',\"Convert to Proportions:\",choices = ['Row','Column','None'],selected = 'None',inline = True)])\n                    #ui.column(2,offset = 0,),  \n                         \n                ),\n                # ui.row(\n                #     ui.column(4,offset = 0, *[ui.input_radio_buttons('transform',\"Convert to Proportions:\",choices = ['Row','Column','None'],selected = 'None',inline = True)])\n                # ),\n                ui.row( \n                    ui.column(3,offset = 1,*[ui.input_selectize(\"fvar\",\"Filter On (select \\\"-\\\" to clear):\" ,choices = ['-'], multiple=False)]),\n                    ui.column(3,offset = 1, *[ui.input_selectize(\"fitems\",\"Included Rows:\",choices = ['-'], multiple=True)]),\n                    ui.column(2,offset = 0, *[ui.input_radio_buttons(\"filterinit\",\"Start with:\",choices = ['All','None'],selected = 'All',inline = True)]),\n                    ui.column(4,offset = 0,)\n                     ),\n                # ui.row(\n                #         ui.HTML(\"<p>Rows Selected (choose \\\"-\\\" to clear filter).</p>\"),\n                #      ),\n                ui.row(height = \"5px\"),\n                ui.row(ui.column(12,offsest = 1,*[ui.output_table(\"pivotDF\")])),\n                ui.row(height = \"5px\"),\n                ui.row(\n                    ui.column(3,offset = 0,*[ui.download_button(\"downloadDP\",\"Save Pivot Table\",width = \"200px\")]),\n                    ui.column(9,offset = 0),\n                ),\n                #  ui.row(\n                #         ui.input_action_button(\"dolog\",\"Show Active Rows\")\n                #  ),\n                #  ui.row(\n                #      ui.output_text_verbatim(\"log\")\n                #      ),\n                ),\n    ui.nav_panel(\"Pivot Plot\",\n                ui.row(\n                    ui.input_radio_buttons(\"pltype\", \"Plot Type:\", choices =['bar','line','barh', 'area','pie','box'],selected = 'bar',inline = True),\n                    ui.input_radio_buttons(\"rotate\", \"Rotate X axis labels:\",choices = ['vertical','horizontal'],selected = 'horizontal',inline = True),\n                    ui.input_text(\"plot_title\",\"Plot Title: \",width = \"800px\")\n                ),\n                ui.row(\n                    ui.output_plot(\"pivot_plot\")\n                ),\n                ),\nunderline = True, title = \"pivot v.0.0.0 \")\n\ndef server(input: Inputs, output: Outputs, session: Session):\n    plt_data = reactive.value(pd.DataFrame())\n    logstr = reactive.value(f\"Log Start: {datetime.now()}\")\n    pvt_data = reactive.value(pd.DataFrame())\n    subdict = reactive.value({})\n##########################################################################\n####  Input panel\n##########################################################################\n    @reactive.calc\n    def parsed_file():\n        #print(\"Starting file read.\")\n        if input.file1() is None:\n            #print(\"No file found in parsed_file.\")\n            return pd.DataFrame()\n        else: \n            fpath = str(input.file1()[0]['datapath'])\n            if (fpath[-4:] == '.csv') or (fpath[-4:] == '.CSV'):\n                df = pd.read_csv(input.file1()[0][\"datapath\"])\n            else:\n                df = pd.read_stata(input.file1()[0][\"datapath\"])\n            #pushlog(\"************************************************\")\n            #print(\"File read: \"  + input.file1()[0]['name'])\n            #pushlog(\"************************************************\")\n            stemp = df.isna().sum().sum()\n            df.replace('',np.nan,inplace = True)\n            stemp = df.isna().sum().sum() - stemp\n            nona = sum(df.isna().sum(axis=1) >0)\n            if (stemp > 0) | (nona > 0):\n                print(f\" {stemp} blank entries converted to NaNs. {nona} rows out of {len(df)} have missing data.\")\n            else:\n                print(\"No rows have missing data.\")\n                \n            #get rid of spaces in column names\n            df.columns = df.columns.str.lstrip()\n            df.columns = df.columns.str.rstrip()\n            df.columns = df.columns.str.replace(' ','_')\n            # df.columns = df.columns.str.replace('[','_')\n            # df.columns = df.columns.str.replace(']','_')\n            # df.columns = df.columns.str.replace('(','_')\n            # df.columns = df.columns.str.replace(')','_')\n            #change names to avoid collisions with protected names\n            #df.columns = [collisionAvoidance(item,protected_names) for item in df.columns]\n            if (input.killna() == 'Yes') : \n                #print(\"Rows with missing values dropped on input by user request.\")\n                df.dropna(inplace = True)\n            #reset plotting data\n            cols = df.columns\n            #print(f\"Setting plt_data. {len(df)} rows.\")\n            plt_data.set(df)\n            num_var = list(df.select_dtypes(include=np.number).columns)\n            str_var = [item for item in cols if item not in num_var]    \n            all_var = list(df.columns)\n\n            ui.update_selectize('valuesV',choices = num_var)\n            #ui.update_selectize('valuesV',choices = all_var)\n            ui.update_selectize('indexV',choices = all_var)\n            ui.update_selectize('columnsV',choices = all_var)\n\n            #reset subsetting data\n            cols = list(df.columns)\n            #print(list(df.columns))\n            #fct used for subsetting (fct short for factor) and coloring\n            fct_var = [item for item in cols if ((item not in num_var) or (len(list(df[item].unique()))<=max_factor_values))]\n            #subset dictionary\n            newdict = {}                \n            newdict = {item: list(map(str,list(df[item].unique()))) for item in fct_var}\n            subdict.set(newdict)\n            num_fct = [item for item in list(df.columns) if (item in num_var) and len(list(df[item].unique())) <= max_factor_values]\n            ui.update_selectize(\"fvar\",choices = ['-']+fct_var)           \n            return df\n        \n    @reactive.effect\n    @reactive.event(input.aggfunV)\n    def chooseValues():\n        df = plt_data()\n        if df.empty : return\n        if ((input.aggfunV() == 'count') or (input.aggfunV() == 'count unique')): \n            ui.update_selectize('valuesV', choices = list(df.columns))\n        else:\n            num_var = list(df.select_dtypes(include=np.number).columns)\n            ui.update_selectize('valuesV', choices = num_var)\n        return\n    \n    @render.data_frame\n    def info():\n        df = parsed_file()\n        if len(df) < 50000 : return\n        #df = plt_data()\n        if df.empty:\n           return \n        #display df.info\n        buffer = io.StringIO()\n        df.info(buf=buffer)\n        slst = buffer.getvalue().splitlines()\n        sdf = pd.DataFrame([item.split() for item in slst[5:-2]],columns = slst[3].split())\n        return sdf\n    \n    @render.data_frame\n    def data():\n        df =parsed_file()\n         #df = plt_data()\n        if df.empty : \n            return\n        if (len(df) > 50000): return\n        return df\n##########################################################################\n####  Create and Render Pivot Table\n##########################################################################\n\n    @reactive.effect\n    @reactive.event(input.transform)\n    def TransformTable():\n        ui.update_radio_buttons('mtotals',selected = 'No')\n        return\n\n    @reactive.effect\n    @reactive.event(input.mtotals)\n    def TransformTable2():\n        ui.update_radio_buttons('transform',selected = 'None')\n        return\n\n\n    @render.table(index=True)\n    #@render.data_frame\n    @reactive.event(input.mtotals, input.aggfunV, input.columnsV, input.indexV, input.valuesV, input.fvar, input.fitems,input.nodig,input.nacode,input.dogrid,input.transform)\n    def pivotDF():\n        aV = input.aggfunV()\n        if aV == \"count unique\":\n            aV = 'nunique'\n        cV = input.columnsV()\n        iV = input.indexV()\n        vV = input.valuesV()\n        if (len(cV) == 0) & (len(iV) == 0) : return\n        #if (len(vV) == 0): return\n        #print(f\"{aV};{list(cV)};{list(iV)};{list(vV)}\")\n        if (plt_data().empty): return\n        dfn = plt_data()\n        #if (aV == '-'): return\n        if (len(cV)==0): \n            cV = []\n        if (len(iV) == 0): \n            iV = []\n        if (len(vV) == 0): return\n        #take out the rows that the user has decided to ignore\n        for item in list(subdict().keys()):\n            dfn = dfn[dfn[item].astype('str').isin(list(subdict()[item]))]\n        MGN=True\n        mgn_title = \"All\"\n        if input.mtotals() == 'No': \n            mgn_title = None\n            MGN = False\n        #all this setup, one line to do the work\n        pivot_table = dfn.pivot_table(values=list(vV), index=list(iV), columns = list(cV), aggfunc= aV,margins = MGN, margins_name = mgn_title )\n        #transform to proportions as needed\n        if (input.transform() == 'Row'):\n            pivot_table = pivot_table.div(pivot_table.sum(axis = 1),axis = 0)\n        elif (input.transform() == 'Column'):\n            pivot_table = pivot_table.div(pivot_table.sum(axis = 0),axis = 1)\n        #and then a little cleanup\n        nc = input.nacode()\n        if nc == 'blank':\n            nc = ''\n        elif nc == '0':\n            nc = 0.0\n        pivot_table.fillna(nc,inplace = True)\n        pivot_table = pivot_table.round(input.nodig())\n        #pivot_table.insert(0,\"; \".join(iV),list(pivot_table.index))\n        pvt_data.set(pivot_table)\n        #print(\"returning pivot table\")\n        #print(pivot_table)\n        #return pivot_table\n        if input.dogrid() == \"Yes\":\n            styled_table = pivot_table.style.set_table_styles([\n                {'selector': 'th', 'props': [('border', '2px solid black')]},\n                {'selector': 'td', 'props': [('border', '1px solid black')]}\n            ])\n            return styled_table.format(precision = input.nodig())\n        else:\n            return pivot_table\n    \n    #event observer to update subsetting dictionary\n    @reactive.effect\n    @reactive.event(input.fvar)\n    def newfilter():\n        df = plt_data()\n        #print(\"In Newfilter\")\n        if len(df) == 0: return\n        #if fvar is not set, restore all rows\n        if (input.fvar() == '-'): \n            #pushlog(\"Resetting row filter, all rows active.\")\n            #fct used for subsetting (fct short for factor)\n            cols = list(df.columns)\n            num_var = list(df.select_dtypes(include=np.number).columns)\n            fct_var = [item for item in cols if ((item not in num_var) or (len(list(df[item].unique()))<=max_factor_values))]\n            #fctc_var = [item for item in fct_var if (len(list(df[item].unique()))<=5)]#10\n            fct_var.insert(0,\"-\")\n            #fctc_var.insert(0,\"-\")\n            newdict = {}\n            newdict = {item: list(map(str,list(df[item].unique()))) for item in fct_var if item != '-'}\n            subdict.set(newdict)\n            ui.update_selectize(\"fitems\",choices = [], selected = [])\n            return\n        fv = input.fvar()\n        cur_items = subdict()[fv]\n        inc_items = list(df[input.fvar()].astype('str').unique())\n        ui.update_selectize(\"fitems\", choices = inc_items, selected = cur_items)\n\n    @reactive.effect\n    @reactive.event(input.fitems)\n    def subdict_update():\n        #update the dictionary of currently active rows keys=col names values = lists of active row values\n        #print(\"In subset Dictionary update\")\n        fv = input.fvar()\n        if (fv == '-'): return\n        newdict = subdict()\n        newdict[fv] = list(input.fitems())\n        subdict.set(newdict)\n        #print(f\"Plot dictionary update:  Var = {fv}; Active values: {', '.join(newdict[fv])}\")\n\n    @reactive.effect\n    @reactive.event(input.filterinit)\n    def setFilter():\n        #print(\"resetting filter\")\n        df = plt_data()\n        if (df.empty) : return\n        if input.fvar() == '-' : return\n        inc_items = list(df[input.fvar()].astype('str').unique())\n        #check to see if we've aready started editing\n        if input.filterinit() == 'All':\n            ui.update_selectize(\"fitems\", choices = inc_items, selected = inc_items)\n        else:\n            ui.update_selectize(\"fitems\", choices = inc_items, selected = [])\n\n\n    # #displays log of currently active rows\n    # @render.text\n    # @reactive.event(input.dolog)\n    # def log():  \n    #     #print(\"In render log\")\n    #     if 1==1: #input.fvar() != '-':\n    #         return '\\n'.join([f'{item}: {subdict()[item]}' for item in subdict().keys()])\n    #     else:\n    #         return \"\"\n        \n\n    @render.plot\n    #@reactive.event(input.updateB)\n    def pivot_plot():\n        df = pvt_data()\n        if df.empty : return\n        if input.pltype() == 'pie':\n            df.plot(kind = 'pie', subplots = True, legend=False, rot = input.rotate(), title = input.plot_title())\n        else:\n            df.plot(kind = input.pltype(),legend = True, rot = input.rotate(), title = input.plot_title())\n\n    @render.download(filename=\"pivot_table_data.csv\")\n    def downloadDP():\n        df = pvt_data()\n        yield df.to_csv(index = True)\n\napp = App(app_ui, server)\n\n", "type": "text"}]