[{"name": "app.py", "content": "import pandas as pd\nimport os as os\nimport numpy as np\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as mpatches\nimport os\nimport io\nimport signal\nfrom datetime import datetime\n\nfrom shiny import App, Inputs, Outputs, Session, reactive, render, ui#from shiny.express import input, render, ui\n#from shinywidgets import render_plotly\n\n#fname = './' + 'AnnArborRealEstate2023-b-noNA.csv'\n#nudata = pd.read_csv(fname)\nprotected_names = ['Residuals','Predictions','Deviance_Resid','CI_lb', 'CI_ub','PI_lb', 'PI_ub']\nmax_factor_values = 50\n\ndef collisionAvoidance(name,namelist):\n    while name in namelist: \n        name = name + '_0'        \n    return(name)\n\n\n# ui.page_opts(title=\"Pivot Tabler\", fillable=True)\n\n# with ui.sidebar():\n#     ui.input_selectize(\n#         \"var\", \"Select variable\",\n#         nudata.columns\n#     )\n#     ui.input_numeric(\"bins\", \"Number of bins\", 30)\n\n#dfn = nudata.copy(deep = True)\naggopts = ['sum','mean','median', 'min', 'max', 'count' , 'std','var']\napp_ui = ui.page_navbar( \n    ui.nav_panel(\"Input\",\n        ui.input_file(\"file1\", \"Choose .csv or .dta File\", accept=[\".csv\",\".CSV\",\".dta\",\".DTA\"], multiple=False, placeholder = ''),\n        ui.input_radio_buttons('killna', 'Remove rows with missing data in one or more columns?',choices = ['No','Yes']),\n        ui.row(ui.output_data_frame(\"info\"), height = '500px'),\n        ui.row(ui.output_data_frame(\"summary\")),\n        ui.row(ui.output_data_frame(\"data\")),\n        ),\n    ui.nav_panel(\"Pivot Table\",\n                ui.row(\n                    ui.column(1,offset = 0,*[ui.input_selectize(\"aggfunV\",\"Aggregation:\",choices = aggopts,selected = 'count', multiple = False,width = \"100px\")]),\n                    ui.column(3,offset = 0,*[ui.input_selectize(\"valuesV\",\"Values to aggregate:\",choices = ['-'],multiple = True, width = \"400px\")]),\n                    ui.column(3,offset = 0,*[ui.input_selectize(\"indexV\" ,\"Group Rows By:\",choices = ['-'],multiple = True,width = \"400px\")]),\n                    ui.column(3,offset = 0, *[ui.input_selectize(\"columnsV\",\"Group Cols By:\",choices = ['-'],multiple = True,width = \"400px\")]),\n                ),\n                ui.row(\n                    #ui.column(4,offset = 0, *[ui.input_radio_buttons('nacode',\"Code Missing Values:\",choices = ['NaN','0','blank'], selected = '0', inline=True)]),\n                    #ui.column(3,offset = 0, *[ui.input_numeric(\"nodig\",\"# of Digits:\", value = 3, min=0, max=10,width='100px')]),\n                    ui.column(3,offset = 0, *[ui.input_radio_buttons('mtotals',\"Show Margins:\",choices = ['Yes','No'],selected = 'No',inline = True)]),   \n                    ui.column(2,offset = 0,),  \n                    ui.column(3,offset = 0,*[ui.download_button(\"downloadDP\",\"Save Pivot Table\",width = \"200px\")]),     \n                ),\n                ui.row(ui.output_table(\"pivotDF\")),\n                ui.row(\n                     ui.column(3,offset = 1,*[ui.input_selectize(\"fvar\",\"Filter On:\" ,choices = ['-'], multiple=False)]),\n                     ui.column(3,offset = 1, *[ui.input_selectize(\"fitems\",\"Included Rows:\",choices = ['-'], multiple=True)]),\n                     ui.column(2,offset = 0, *[ui.input_radio_buttons(\"filterinit\",\"Start with:\",choices = ['All','None'],selected = 'All',inline = True)]),\n                     ui.column(4,offset = 0,)\n                     ),\n                 ui.row(\n                        ui.HTML(\"<p>Rows Selected (filter on \\\"-\\\" above to clear filter).</p>\"),\n                     ),\n                 ui.row(\n                     ui.output_text_verbatim(\"log\")\n                     ),\n                ),\n    ui.nav_panel(\"Pivot Plot\",\n                ui.row(\n                    ui.input_radio_buttons(\"pltype\", \"Plot Type:\", choices =['bar','line','barh', 'area'],selected = 'bar',inline = True),\n                ),\n                ui.row(\n                    ui.output_plot(\"pivot_plot\"), height=\"900px\"\n                ),\n                ),\nunderline = True, title = \"pivot v.0.0.0 \")\n\ndef server(input: Inputs, output: Outputs, session: Session):\n    plt_data = reactive.value(pd.DataFrame())\n    logstr = reactive.value(f\"Log Start: {datetime.now()}\")\n    pvt_data = reactive.value(pd.DataFrame())\n    subdict = reactive.value({})\n##########################################################################\n####  Input panel\n##########################################################################\n\n    @reactive.calc\n    def parsed_file():\n        #print(\"Starting file read.\")\n        if input.file1() is None:\n            #print(\"No file found in parsed_file.\")\n            return pd.DataFrame()\n        else: \n            fpath = str(input.file1()[0]['datapath'])\n            if (fpath[-4:] == '.csv') or (fpath[-4:] == '.CSV'):\n                df = pd.read_csv(input.file1()[0][\"datapath\"])\n            else:\n                df = pd.read_stata(input.file1()[0][\"datapath\"])\n            #pushlog(\"************************************************\")\n            #print(\"File read: \"  + input.file1()[0]['name'])\n            #pushlog(\"************************************************\")\n            stemp = df.isna().sum().sum()\n            df.replace('',np.nan,inplace = True)\n            stemp = df.isna().sum().sum() - stemp\n            nona = sum(df.isna().sum(axis=1) >0)\n            if (stemp > 0) | (nona > 0):\n                print(f\" {stemp} blank entries converted to NaNs. {nona} rows out of {len(df)} have missing data.\")\n            else:\n                print(\"No rows have missing data.\")\n                \n            #get rid of spaces in column names\n            df.columns = df.columns.str.lstrip()\n            df.columns = df.columns.str.rstrip()\n            df.columns = df.columns.str.replace(' ','_')\n            # df.columns = df.columns.str.replace('[','_')\n            # df.columns = df.columns.str.replace(']','_')\n            # df.columns = df.columns.str.replace('(','_')\n            # df.columns = df.columns.str.replace(')','_')\n            #change names to avoid collisions with protected names\n            #df.columns = [collisionAvoidance(item,protected_names) for item in df.columns]\n            if (input.killna() == 'Yes') : \n                #print(\"Rows with missing values dropped on input by user request.\")\n                df.dropna(inplace = True)\n            #reset plotting data\n            cols = df.columns\n            #print(f\"Setting plt_data. {len(df)} rows.\")\n            plt_data.set(df)\n            num_var = list(df.select_dtypes(include=np.number).columns)\n            str_var = [item for item in cols if item not in num_var]    \n            all_var = list(df.columns)\n\n            ui.update_selectize('valuesV',choices = num_var)\n            ui.update_selectize('indexV',choices = all_var)\n            ui.update_selectize('columnsV',choices = all_var)\n\n            #reset subsetting data\n            cols = list(df.columns)\n            #print(list(df.columns))\n            #fct used for subsetting (fct short for factor) and coloring\n            fct_var = [item for item in cols if ((item not in num_var) or (len(list(df[item].unique()))<=max_factor_values))]\n            #subset dictionary\n            newdict = {}                \n            newdict = {item: list(map(str,list(df[item].unique()))) for item in fct_var}\n            subdict.set(newdict)\n            num_fct = [item for item in list(df.columns) if (item in num_var) and len(list(df[item].unique())) <= max_factor_values]\n            ui.update_selectize(\"fvar\",choices = ['-']+fct_var)           \n            return df\n        \n    @reactive.effect\n    @reactive.event(input.aggfunV)\n    def chooseValues():\n        df = plt_data()\n        if df.empty : return\n        if (input.aggfunV == 'count') : \n            ui.update_selectize('valuesV', choices = list(df.columns))\n        else:\n            num_var = list(df.select_dtypes(include=np.number).columns)\n            ui.update_selectize('valuesV', choices = num_var)\n        return\n    \n    @render.data_frame\n    def info():\n        df = parsed_file()\n        if len(df) < 50000 : return\n        #df = plt_data()\n        if df.empty:\n           return \n        #display df.info\n        buffer = io.StringIO()\n        df.info(buf=buffer)\n        slst = buffer.getvalue().splitlines()\n        sdf = pd.DataFrame([item.split() for item in slst[5:-2]],columns = slst[3].split())\n        return sdf\n    \n    @render.data_frame\n    def data():\n        df =parsed_file()\n         #df = plt_data()\n        if df.empty : \n            return\n        if (len(df) > 50000): return\n        return df\n##########################################################################\n####  Create and Render Pivot Table\n##########################################################################\n\n    @render.table(index=True)\n    @reactive.event(input.mtotals, input.aggfunV, input.columnsV, input.indexV, input.valuesV, input.fvar, input.fitems)\n    def pivotDF():\n        aV = input.aggfunV()\n        cV = input.columnsV()\n        iV = input.indexV()\n        vV = input.valuesV()\n        if (len(cV) == 0) & (len(iV) == 0) : return\n        #if (len(vV) == 0): return\n        #print(f\"{aV};{list(cV)};{list(iV)};{list(vV)}\")\n        if (plt_data().empty): return\n        dfn = plt_data()\n        #if (aV == '-'): return\n        if (len(cV)==0): \n            cV = []\n        if (len(iV) == 0): \n            iV = []\n        if (len(vV) == 0): return\n        #take out the rows that the user has decided to ignore\n        for item in list(subdict().keys()):\n            dfn = dfn[dfn[item].astype('str').isin(list(subdict()[item]))]\n        MGN=True\n        mgn_title = \"All\"\n        if input.mtotals() == 'No': \n            mgn_title = None\n            MGN = False\n        #all this setup, one line to do the work\n        pivot_table = dfn.pivot_table(values=list(vV), index=list(iV), columns = list(cV), aggfunc= aV,margins = MGN, margins_name = mgn_title )\n        #and then a little cleanup\n        ##print(f\"Rounding to {input.nodig()} places.\")\n        #pivot_table.round(input.nodig())\n        ##print(f\"Recoding NaNs to {input.nacode()}\")\n        #if input.nacode() != 'NaN': pivot_table.fillna(input.nacode())\n        #pivot_table.insert(0,\"; \".join(iV),list(pivot_table.index))\n        pvt_data.set(pivot_table)\n        #print(\"returning pivot table\")\n        #print(pivot_table)\n        return pivot_table\n    \n    #event observer to update subsetting dictionary\n    @reactive.effect\n    @reactive.event(input.fvar)\n    def newfilter():\n        df = plt_data()\n        #print(\"In Newfilter\")\n        if len(df) == 0: return\n        #if fvar is not set, restore all rows\n        if (input.fvar() == '-'): \n            #pushlog(\"Resetting row filter, all rows active.\")\n            #fct used for subsetting (fct short for factor)\n            cols = list(df.columns)\n            num_var = list(df.select_dtypes(include=np.number).columns)\n            fct_var = [item for item in cols if ((item not in num_var) or (len(list(df[item].unique()))<=max_factor_values))]\n            #fctc_var = [item for item in fct_var if (len(list(df[item].unique()))<=5)]#10\n            fct_var.insert(0,\"-\")\n            #fctc_var.insert(0,\"-\")\n            newdict = {}\n            newdict = {item: list(map(str,list(df[item].unique()))) for item in fct_var if item != '-'}\n            subdict.set(newdict)\n            ui.update_selectize(\"fitems\",choices = [], selected = [])\n            return\n        fv = input.fvar()\n        cur_items = subdict()[fv]\n        inc_items = list(df[input.fvar()].astype('str').unique())\n        ui.update_selectize(\"fitems\", choices = inc_items, selected = cur_items)\n\n    @reactive.effect\n    @reactive.event(input.fitems)\n    def subdict_update():\n        #update the dictionary of currently active rows keys=col names values = lists of active row values\n        #print(\"In subset Dictionary update\")\n        fv = input.fvar()\n        if (fv == '-'): return\n        newdict = subdict()\n        newdict[fv] = list(input.fitems())\n        subdict.set(newdict)\n        #print(f\"Plot dictionary update:  Var = {fv}; Active values: {', '.join(newdict[fv])}\")\n\n    @reactive.effect\n    @reactive.event(input.filterinit)\n    def setFilter():\n        #print(\"resetting filter\")\n        df = plt_data()\n        if (df.empty) : return\n        if input.fvar() == '-' : return\n        inc_items = list(df[input.fvar()].astype('str').unique())\n        #check to see if we've aready started editing\n        if input.filterinit() == 'All':\n            ui.update_selectize(\"fitems\", choices = inc_items, selected = inc_items)\n        else:\n            ui.update_selectize(\"fitems\", choices = inc_items, selected = [])\n\n\n    #displays log of currently active rows\n    @render.text\n    @reactive.event(input.fvar,input.fitems, input.aggfunV, input.columnsV, input.indexV, input.valuesV)\n    def log():  \n        #print(\"In render log\")\n        if 1==1: #input.fvar() != '-':\n            return '\\n'.join([f'{item}: {subdict()[item]}' for item in subdict().keys()])\n        else:\n            return \"\"\n        \n\n\n\n    @render.plot\n    #@reactive.event(input.updateB)\n    def pivot_plot():\n        df = pvt_data()\n        if df.empty : return\n        df.plot(kind = input.pltype())\n\n    @render.download(filename=\"pivot_table_data.csv\")\n    def downloadDP():\n        df = pvt_data()\n        #print(f\"from render download {df}\")\n        #create the row subset for graphing    \n        #for item in list(subdict().keys()):\n        #    df = df[df[item].astype('str').isin(list(subdict()[item]))]\n        yield df.to_csv(index = True)\n\napp = App(app_ui, server)\n\n", "type": "text"}]